#include <stdio.h>#include <stdlib.h>#include <string.h>#include <assert.h>#include <getopt.h>#include <fcntl.h>#include <unistd.h>#include <errno.h>#include <sys/stat.h>#include <sys/types.h>#include <arpa/inet.h>#include <sys/time.h>#include <sys/mman.h>#include <sys/ioctl.h>#include <asm/types.h>#include <linux/videodev2.h>#include <linux/fb.h>#include <malloc.h>#include <pthread.h>#include <math.h>#include <sys/socket.h>#include <netinet/in.h> #include <netinet/tcp.h>#include <fcntl.h>#include <list>#include <map>#include <time.h>#include "streamlib.h"#include "UvcCamera.h"#define LENGTH_OF_LISTEN_QUEUE				5#define MY_SERVER_PORT						5500#define CLEAR(x)   memset(&(x), 0, sizeof (x))#define BUF_SIZE 							1*1024*1024 // 1MB#define MSG_DATA_LEN						1*1024*1024//128*1024 //5*1024*1024#define MSG_SET_PARAM						0xa401//设置参数#define MSG_GET_PARAM						0xa402//获取参数#define MSG_GET_VERSION_INFO				0xa804//版本信息#define MSG_REQUEST_VIDEO					0xaa01//请求音视频/抓图#define MSG_CLOSE_VIDEO						0xaa02//关闭音视频/抓图#define MSG_UPDATE_USER						0xaa20#define MSG_UPDATE_STATE					0xaa21#define PARAM_VIDEO1_ENCODE					0xb00E//主码流编码参数#define PARAM_VIDEO2_ENCODE					0xb024//子码流编码参数#define PARAM_VIDEO_ENTER					0xb097//入侵 #define PARAM_VIDEO_PASS					0xb098//越界#define PARAM_VIDEO_COVER					0xb099//遮挡#define PARAM_LOCALTIME						0xb301//设置获取时间#define	ACK_ERR_OTHER						0xff#define	ACK_SUCCESSFUL						0x00#define DEVICE_NAME							"/dev/video1"#define  GM_MAX_TIME_SEG_NUM				4typedef enum{	PTC_VIDEO_ENCODE_NONE = 0,	PTC_VIDEO_ENCODE_H264,	PTC_VIDEO_ENCODE_MJPEG,	PTC_VIDEO_ENCODE_MPEG4,}PTC_VIDEO_ENCODE_E;typedef enum{	PTC_AUDIO_ENCODE_NONE,	PTC_AUDIO_ENCODE_G711A,	PTC_AUDIO_ENCODE_ADPCM,	PTC_AUDIO_ENCODE_G711U,	PTC_AUDIO_ENCODE_PCM,}PTC_AUDIO_ENCODE_E;typedef struct _send_msg_t{	int msg_type;	int sub_type;	void* p_buffer;	int size;}send_msg_t;typedef struct{	int cmd;//1:开视频,2:关视频,3心跳	int ch;//0:主码流,1:子码流	int res;//0:成功,1:失败}pd_msg_t;typedef struct{	int fd;	int ch;}local_preview_param_t;typedef struct _msg_preview_t{	int stream;				//码流:0-主码流，1-子码流	int datatype;			//请求数据类型:0-音视频，1-视频，2-音频，3-抓拍图片	int reserved;			//预留}msg_preview_t;typedef struct __time_seg_t{    unsigned char	start_hour;    unsigned char	start_minute;    unsigned char	start_second;    unsigned char	end_hour;    unsigned char	end_minute;    unsigned char	end_second;    unsigned char 	unused[2];} time_seg_t;typedef struct __time_schedule_day_t{    time_seg_t	time_seg[GM_MAX_TIME_SEG_NUM];     	/* ʱ��� */} time_schedule_day_t;typedef struct __time_schedule_week_t{    char			enable_flag;    unsigned char 	unused[3];    time_schedule_day_t	time_schedule_day[7];} time_schedule_week_t;typedef struct __alarm_linkage_t{    int			snapshot_ch;	/* 按位表示通道，从低位开始 eg: 二进制 0011 十六进制 0x3 表示联动 第1和第2通道*/    int			record_ch;		/* 按位表示通道，从低位开始 eg: 二进制 0011 十六进制 0x3 表示联动 第1和第2通道*/    int			output_ch;		/* 按位表示通道，从低位开始 eg: 二进制 0011 十六进制 0x3 表示联动 第1和第2通道*/    unsigned char	sound_enable;    unsigned char	snapshot_num;    unsigned short	output_sec;    unsigned short	record_sec;    unsigned short	sound_sec;    //新增 mail ftp    unsigned char	mail_enable;    unsigned char	mail_include_picture_enable;//0:文本 1:文本及图片    unsigned char	ftp_enable;    unsigned char	ftp_include_picture_enable;//0:文本 1:文本及图片    unsigned char 	unused[16];} alarm_linkage_t;typedef struct __xarina_ta_alarm_t{	int enable; 	time_schedule_week_t time_schedule_week;	alarm_linkage_t alarm_linkage;}xarina_ta_arlam_t;	//�ڵ�typedef struct __point_t{	float x;	float y;}point_t;typedef struct __rect_t{	point_t  locate_point[4]; } rect_t;typedef struct __xarina_vmf_info_t{	int enable; //是否启用	unsigned short  event; // 0 entering  1 passing 3	unsigned short pointnum;// 2 直线（边界报警） 4 区域 （入侵、丢失报警）	rect_t vmf_rect; //直线(填充0,1 ) 或 区域 	unsigned short  sensitive_level; //灵敏度 高 中 低  	unsigned short movingDirection; // 0：双向 1：to right  2：to left  (边界报警有效，其他默认为0)	time_schedule_week_t time_schedule_week;	alarm_linkage_t alarm_linkage;}xarina_vmf_info_t;	//越界、入侵typedef struct __frame_head_t{	unsigned long device_type;//固定	unsigned long frame_size;	unsigned long frame_no;	unsigned long width;//视频宽	unsigned long height;//视频高	unsigned long channel;//通道号，用于区分主子码流 0-主码流，1-子码流	unsigned char video_resolution;	//暂时不用的	unsigned char frame_type;//I/P帧，音频帧，控制应答帧	unsigned char frame_rate;//帧率	unsigned char video_standard;	unsigned long sec;	unsigned long usec;	unsigned long long pts;}frame_head_t;typedef struct __frame_t{	frame_head_t   frame_head;	unsigned char *frame_data;} frame_t;typedef struct __msg_head_t{	unsigned short msg_type;			//消息类型	unsigned short msg_subtype;			//消息子类型	unsigned int msg_size;				//消息长度		unsigned char ack_flag;				//确认标志	unsigned char reserved[7];}msg_head_t;typedef struct __net_msg_t{	msg_head_t	msg_head;		//消息头	char	msg_data[MSG_DATA_LEN];		//消息数据}net_msg_t;typedef enum _STREAM_FRAME_TYPE_E{    STREAM_I_FRAME_TYPE = 1,	// I帧    STREAM_P_FRAME_TYPE,		// P帧    STREAM_A_FRAME_TYPE,		// 音频帧    STREAM_C_MSG_TYPE,			// 控制指令    STREAM_C_ALARM_TYPE,		// 报警数据} STREAM_FRAME_TYPE_E;struct buffer{		void *start;	size_t length;};struct buffer * buffers=NULL;static unsigned int n_buffers=0;static int gfd = -1;static int run = 0;static time_t ltime = 0;static int main_flag = 0;static int sub_flag = 0;static int cover_state = 0;static int pass_state = 0;static int enter_state = 0;static alarm_callback g_cb_alarm = NULL;pthread_mutex_t mtx_opreview	= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_opreview	= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_spreview	= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_spreview	= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_sparam		= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_sparam		= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_gparam		= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_gparam		= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_version		= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_version		= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_update	= PTHREAD_MUTEX_INITIALIZER;pthread_cond_t cond_update	= PTHREAD_COND_INITIALIZER;pthread_mutex_t mtx_ctrl		= PTHREAD_MUTEX_INITIALIZER;pthread_mutex_t mtx_send 		= PTHREAD_MUTEX_INITIALIZER;static std::list<send_msg_t*> g_list_send;static std::map<int, char*> g_map_msg;static int reconnect = 0;static upgrade_callback UpgradeCallback = NULL;static offline_callback OfflineCallback = NULL;int recvn(int fd, char *vptr, int n, int flag){	int nleft, nread;	char    *ptr;	ptr = vptr;	nleft = n;	while (nleft > 0)	{		if ((nread = recv(fd, ptr, nleft, flag)) < 0)		{			if(errno == EAGAIN || errno == EINTR)				continue;			return(-1);		}		else if (nread == 0)		{			break;  //EOF		}		nleft -= nread;		ptr += nread;	}	return(n - nleft);}int sendn(int fd, const void* vptr, size_t n, int flag){	size_t nleft;	ssize_t nwritten;	const char * ptr;		ptr = (const char*)vptr;	nleft = n;	while(nleft > 0)	{		if( (nwritten = send(fd, ptr, nleft, flag)) <= 0)		{			if(nwritten < 0 && (errno == EINTR || errno == EAGAIN))			{				nwritten = 0;			}			else			{				return (-1);			}		}		nleft -= nwritten;		ptr += nwritten;	}	return (n);}static void* preview_thread(void* param){	local_preview_param_t* p = (local_preview_param_t*)param;	if(p == NULL)	{		return NULL;	}	int clientfd = p->fd;		int first = 1;	int ch = p->ch;	ptc_frame_head_t frame_head;	ptc_frame_video_t pVideo;	char *frame_pos;	stream_rpos_t rpos;	int send_IFrameflag = 1;	while(run)	{		if(first)		{			qh_stream_getLastPos(ch, 0, &rpos);			first = 0;		}		frame_pos = qh_getOneFrame(ch, &rpos);		if(frame_pos == NULL)		{			usleep(1000*5);			continue;		}				memcpy(&frame_head, frame_pos, sizeof(ptc_frame_head_t));// 取帧头				if(send_IFrameflag == 1)	//第一帧需要发送I帧		{            if ((frame_head.frame_type != 1)&&(frame_head.frame_type != 6))			{				//printf("%s --> %s --> L%d : send_IFrameflag == 1 \n", __FILE__, __FUNCTION__, __LINE__);				continue;			}			send_IFrameflag = 0;		}				memset(&pVideo, 0, sizeof(ptc_frame_video_t));		memcpy(&pVideo.frame_head, &frame_head, sizeof(ptc_frame_head_t));		memcpy(pVideo.frame_body, frame_pos+sizeof(ptc_frame_head_t), frame_head.len);				int left_size = frame_head.len + sizeof(ptc_frame_head_t);		if(left_size > STREAM_MAX_LEN)		{			printf("%s --> %s --> L%d : sget tcp net frame too len = %d \n", __FILE__, __FUNCTION__, __LINE__, frame_head.len);			left_size = 300*1024;			continue;		}		int nRet = sendn(clientfd, (const void*)&pVideo, left_size, 0);		int err = errno;		if (nRet != left_size)		{			printf("%s --> %s --> L%d : send error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, err, strerror(err));			break;		}	}		printf("%s --> %s --> L%d : close preview thread \n", __FILE__, __FUNCTION__, __LINE__);	return NULL;}static void* client_cmd_thread(void* param){	int* p_clientfd =  (int*)param;	int clientfd = *p_clientfd;	int pid = -1;	int pflag = 0;	int ch = 0;		int flags = 1;    setsockopt(clientfd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags));    setsockopt(clientfd, SOL_TCP, TCP_NODELAY, &flags, sizeof(flags));	fcntl(clientfd, F_SETFL, fcntl(clientfd, F_GETFL, 0)|O_NONBLOCK);	while(run)	{		//判断是否有可读信息		fd_set rset;		FD_ZERO(&rset);		FD_SET(clientfd, &rset);		struct timeval tval;		tval.tv_sec = 0;		tval.tv_usec = 10;		int err = select(clientfd+1, &rset, 0, 0, &tval);		if (err < 0)		{//<0表示错误，=0表示超时			printf("%s --> %s --> L%d : select error[%d:%s]  \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			if(pflag > 0)			{				pflag = 0;			}			close(clientfd);			clientfd = -1;			break;		}		else if (err > 0)		{//可读			pd_msg_t msg;			memset(&msg, 0, sizeof(pd_msg_t));			int len = recvn(clientfd, (char *)&msg, sizeof(pd_msg_t), 0);			if (len != sizeof(pd_msg_t))			{				printf("%s --> %s --> L%d : Recv msg_head failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));				if (len < 0)				{					if (errno == EINTR || errno == EAGAIN)					{						continue;					}				}				close(clientfd);				clientfd = -1;				break;			}			//printf("%s --> %s --> L%d : recv msg.cmd[%d] msg.ch[%d] \n", __FILE__, __FUNCTION__, __LINE__, msg.cmd, msg.ch);			if(msg.cmd == 1)			{				if(pflag == 0)				{					printf("%s --> %s --> L%d : recv open msg \n", __FILE__, __FUNCTION__, __LINE__);					pid = qh_cam_status();					if(pid != 0)					{						pflag = 1;						ch = msg.ch;						msg.res = 0;						int ret = sendn(clientfd, &msg, sizeof(pd_msg_t), 0);						if (ret != sizeof(pd_msg_t))						{							printf("%s --> %s --> L%d : send pd hb failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));							close(clientfd);							clientfd = -1;							break;						}						local_preview_param_t param;						param.ch = msg.ch;						param.fd = clientfd;						//创建工作线程						pthread_t id_preview;						pthread_create(&id_preview, NULL, preview_thread, (void*)&param);						printf("qh_cam_preview success\n");					}					else					{						msg.res = 1;						int ret = sendn(clientfd, &msg, sizeof(pd_msg_t), 0);						if (ret != sizeof(pd_msg_t))						{							printf("%s --> %s --> L%d : send pd hb failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));							close(clientfd);							clientfd = -1;							break;						}						break;					}				}			}			else			{				if(pflag > 0)				{					pflag = 0;				}				close(clientfd);				clientfd = -1;				printf("%s --> %s --> L%d : recv close msg \n", __FILE__, __FUNCTION__, __LINE__);				break;			}		}		else		{			usleep(100*1000);		}	}	if(clientfd != -1)	{		close(clientfd);		clientfd = -1;	}	return NULL;}static int init_server(){	int listenfd = socket(AF_INET, SOCK_STREAM, 0);	if (listenfd < 0)	{		printf("%s --> %s --> L%d : socket failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		return listenfd;	}	    struct sockaddr_in server_addr; 	memset(&server_addr, 0, sizeof(server_addr));    server_addr.sin_family = AF_INET;     server_addr.sin_addr.s_addr = htons(INADDR_ANY);     server_addr.sin_port = htons(MY_SERVER_PORT); 	    if(bind(listenfd,(struct sockaddr*)&server_addr,sizeof(server_addr)))     {		printf("%s --> %s --> L%d : Server Bind Port : %d Failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, MY_SERVER_PORT, errno, strerror(errno));		close(listenfd);        return -1;     }     if (listen(listenfd, LENGTH_OF_LISTEN_QUEUE))    {		printf("%s --> %s --> L%d : Server Listen Failed, error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));        close(listenfd);        return -1;    }		return listenfd;}static void* server_work_thread(void* param){	int listenfd = init_server();	if (listenfd < 0)	{		printf("%s --> %s --> L%d : init_server failed error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		return NULL;	}	//printf("server_work_thread run initserver() success \n");	while(run)	{		struct sockaddr_in cliaddr;		int len = sizeof(cliaddr);		int connfd = accept(listenfd, (struct sockaddr*)&cliaddr, &len);		if(connfd == -1)		{			printf("%s --> %s --> L%d : accept error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			continue;		}		char buff[20] = {0};		printf("connection from %s, port %d, connfd %d\n", inet_ntop(AF_INET, &cliaddr.sin_addr, buff, sizeof(buff)), ntohs(cliaddr.sin_port), connfd);		//创建工作线程		pthread_t id_preview;		pthread_create(&id_preview, NULL, client_cmd_thread, (void*)(&connfd));	}	return NULL;}static int Send(unsigned char * send,int length){	if(gfd == -1)	{		printf("%s --> %s --> L%d : fd = -1 send failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}		int cb = 0;	int sendlen = 0;	net_msg_t* p_msg = (net_msg_t*)send;	if(p_msg->msg_head.msg_type == MSG_UPDATE_USER)	{		cb = 1;	}	struct v4l2_event s_data;	int counts;	int i;	int ii;	int lengths;	if(length >60)	{		counts = length/60 + 1;		for(i=0; i<counts; i++)		{			if(length-(i+1)*60>0)			{					CLEAR(s_data);				memcpy(s_data.u.data,send+i*60,60);				lengths=60;			}			else			{				CLEAR(s_data);				lengths=length-i*60;				memcpy(s_data.u.data,send+i*60,lengths);			}			s_data.type=1;			s_data.sequence=lengths;			usleep(100*1000);			pthread_mutex_lock(&mtx_ctrl);			if (-1 == ioctl(gfd, VIDIOC_S_FMT, &s_data))			{				printf("%s --> %s --> L%d : VIDIOC_S_FMT failed! errno[%d] %s\n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));				pthread_mutex_unlock(&mtx_ctrl);				char* p_buf = (char*)malloc(sizeof(net_msg_t));				memset(p_buf, 0, sizeof(net_msg_t));				net_msg_t* net_msg = (net_msg_t*)p_buf;				net_msg->msg_head.ack_flag = ACK_ERR_OTHER;				g_map_msg[MSG_UPDATE_USER] = p_buf;				pthread_mutex_lock(&mtx_update);				pthread_cond_signal(&cond_update);				pthread_mutex_unlock(&mtx_update);				return -1;			}			pthread_mutex_unlock(&mtx_ctrl);			sendlen += lengths;			if(UpgradeCallback && cb)			{				UpgradeCallback(sendlen, length);			}		}		//printf("send suceess\n");	}	else	{		CLEAR(s_data);		memcpy(s_data.u.data,send,length);		s_data.type=1;		s_data.sequence=length;		usleep(10*1000);		pthread_mutex_lock(&mtx_ctrl);		if (-1 == ioctl(gfd, VIDIOC_S_FMT, &s_data))		{			printf("%s --> %s --> L%d : VIDIOC_S_FMT failed! errno[%d] %s\n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			pthread_mutex_unlock(&mtx_ctrl);			return -1;		}		pthread_mutex_unlock(&mtx_ctrl);		//printf("send suceess\n");	}	return 0;}static int SendData(int msg_type, int msg_subtype, void* pBuffer, int nBufSize){	net_msg_t* p_msg = (net_msg_t*)malloc(sizeof(net_msg_t));	if(p_msg)	{	    p_msg->msg_head.msg_type = msg_type;        p_msg->msg_head.msg_subtype = msg_subtype;        p_msg->msg_head.msg_size = nBufSize;        memcpy(p_msg->msg_data, (char*)pBuffer, nBufSize);        int nSendSize = sizeof(msg_head_t) + nBufSize;        int nRet = Send((unsigned char*)p_msg, nSendSize);        free(p_msg);    	return nRet;	}	else	{	    return -1;	}}static int InitPreviewMem(int fd){	//���뻺��	struct v4l2_requestbuffers req;	CLEAR (req);	req.count=4;	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;	req.memory = V4L2_MEMORY_MMAP;	//���������ڴ�	int rets = ioctl(fd, VIDIOC_REQBUFS, &req);	if(rets < 0)	{		printf("%s --> %s --> L%d : errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		return -1;	}	//����req.count��sizeof��*buffers����С�������ڴ�	buffers=(struct buffer *)calloc(req.count, sizeof(*buffers));	if (!buffers)	{		printf("%s --> %s --> L%d : errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		return -1;	}	//ӳ��	for(n_buffers=0; n_buffers<req.count; ++n_buffers)	{		struct v4l2_buffer buf1;		CLEAR (buf1);		buf1.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;		buf1.memory = V4L2_MEMORY_MMAP;		buf1.index = n_buffers;		//�����ѯ���뵽���ڴ�		if(-1 == ioctl(fd,VIDIOC_QUERYBUF,&buf1))		{			printf("%s --> %s --> L%d : VIDIOC_QUERYBUF errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			free(buffers);			return -1;		}		buffers[n_buffers].length = buf1.length;		buffers[n_buffers].start =mmap(NULL, buf1.length, PROT_READ|PROT_WRITE,	MAP_SHARED, fd, buf1.m.offset);		if (MAP_FAILED == buffers[n_buffers].start)		{			printf("%s --> %s --> L%d : mmap errno \n", __FILE__, __FUNCTION__, __LINE__);			int i = 0;			for(i = 0; i < n_buffers; i++)			{				munmap(buffers[i].start, buffers[i].length);			}			free(buffers);			n_buffers = 0;			return -1;		}	}	//��������	int i = 0;	for(i=0; i<n_buffers; i++)	{		struct v4l2_buffer buf2;		CLEAR (buf2);		buf2.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;		buf2.memory = V4L2_MEMORY_MMAP;		buf2.index = i;		//����		if (-1 == ioctl(fd, VIDIOC_QBUF, &buf2))		{			printf("%s --> %s --> L%d : VIDIOC_QBUF errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			int y = 0;			for(y = 0; y < n_buffers; y++)			{				munmap(buffers[y].start, buffers[y].length);			}			free(buffers);			n_buffers = 0;			return -1;		}	}	//�ɼ���Ƶ��	enum v4l2_buf_type type;	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;	if (-1 == ioctl(fd, VIDIOC_STREAMON, &type))	{		printf("%s --> %s --> L%d : VIDIOC_STREAMON errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		for(i = 0; i < n_buffers; i++)		{			munmap(buffers[i].start, buffers[i].length);		}		free(buffers);		n_buffers = 0;		return -1;	}	return 0;}static int OpenUvcCamera(void){	int fd = -1;	struct stat st;	if(-1 == stat(DEVICE_NAME,&st))	{		printf("%s --> %s --> L%d : Cannot identify '%s' errno[%d]:%s \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME, errno, strerror(errno));		return -1;	}	if(!S_ISCHR(st.st_mode))	{		printf("%s --> %s --> L%d : '%s' is not device \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME);		return -1;	}	if((fd = open(DEVICE_NAME, O_RDWR|O_NONBLOCK)) == -1)	{		printf("%s --> %s --> L%d : open '%s' failed: error[%d], strerr[%s] \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME, errno, strerror(errno));		return -1;	}	struct v4l2_capability cap;	//��ȡ����	int rets =  ioctl(fd,VIDIOC_QUERYCAP,&cap);	if(rets < 0)	{		printf("%s --> %s --> L%d : VIDIOC_QUERYCAP failture \n", __FILE__, __FUNCTION__, __LINE__);		close(fd);		fd = -1;		return -1;	}	if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE))	{		printf("%s --> %s --> L%d : '%s' is not video capture device \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME);		close(fd);		fd = -1;		return -1;	}	if (!(cap.capabilities & V4L2_CAP_STREAMING))	{		printf("%s --> %s --> L%d : '%s' does not support streaming i/o \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME);		close(fd);		fd = -1;		return -1;	}	rets = InitPreviewMem(fd);	if(rets == -1)	{		printf("%s --> %s --> L%d : '%s' InitPreviewMem failed \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME);		close(fd);		fd = -1;		return -1;	}	return fd;}static void CleanPreviewMem(){	enum v4l2_buf_type type;	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;	ioctl(gfd, VIDIOC_STREAMOFF, &type);	if(buffers != NULL)	{		int i = 0;		for(i = 0; i < n_buffers; i ++)		{			munmap(buffers[i].start, buffers[i].length);		}		free(buffers);		buffers = NULL;		n_buffers = 0;	}}static void CloseDevide(void){	CleanPreviewMem();	if(gfd != -1)	{		close(gfd);		gfd = -1;	}}static int check_head(char *buf){	// ֡ͷǰ�ĸ��ֽ�Ϊ 0x48510001(ע���ֽ���)	//printf("%#x,%#x,%#x,%#x\n", buf[0], buf[1], buf[2], buf[3]);	if((buf[0] == 0x01) && (buf[1] == 0x00) && (buf[2] == 0x51) && (buf[3] == 0x48))	{		// ��ͷ��ȷ		return 0;	}	else	{		return -1;	}}unsigned char * ProcessImageData (const void *p,unsigned int length){	int len = length;	char* p_data = (char*)p;	while(len > 0 && p_data)	{		if(len < sizeof(frame_head_t))		{			break;		}		else		{			if(check_head(p_data) < 0)			{				p_data += 2;				len -= 2;				continue;			}		}		/*********************************************************/		frame_head_t* p_head = (frame_head_t*)p_data;		frame_t* p_frame = (frame_t*)p_data;		//printf("frame_type:%d,frame_size:%d\n",p_head->frame_type, p_head->frame_size);		switch (p_head->frame_type)		{			case STREAM_I_FRAME_TYPE:			case STREAM_P_FRAME_TYPE:			case STREAM_A_FRAME_TYPE:			{				//printf("channel:%d,type:%d\n",p_head->channel, p_head->frame_type);				ptc_frame_video_t* pVideo = (ptc_frame_video_t*)malloc(sizeof(ptc_frame_video_t));				if(pVideo == NULL)				{					printf("%s --> %s --> L%d : malloc pVideo failed \n", __FILE__, __FUNCTION__, __LINE__);					break;				}				memset(pVideo,0,sizeof(ptc_frame_video_t));				pVideo->frame_head.len = p_head->frame_size;				pVideo->frame_head.frame_rate = p_head->frame_rate;				pVideo->frame_head.width = p_head->width;				pVideo->frame_head.height = p_head->height;				pVideo->frame_head.frame_type = p_head->frame_type;				pVideo->frame_head.sec = p_head->sec;				pVideo->frame_head.usec = p_head->usec;				pVideo->frame_head.frame_rate = p_head->frame_rate;				pVideo->frame_head.channel_type = p_head->channel;				pVideo->frame_head.no = p_head->frame_no;				pVideo->frame_head.channel_no = 0;				if(p_head->frame_type == STREAM_A_FRAME_TYPE)				{					pVideo->frame_head.frame_sub_type = PTC_AUDIO_ENCODE_G711A;				}				else				{					pVideo->frame_head.frame_sub_type =PTC_VIDEO_ENCODE_H264;				}				memcpy(pVideo->frame_body, p_data+sizeof(frame_head_t), p_head->frame_size);				stream_frame_t frame;				memset(&frame, 0, sizeof(stream_frame_t));				frame.ch = p_head->channel;				memcpy(&frame.frame_head, pVideo, sizeof(ptc_frame_head_t));				frame.frame_data = (unsigned char *)malloc(pVideo->frame_head.len);				if(frame.frame_data == NULL)				{					//printf("%s --> %s --> L%d : malloc frame.frame_data failed \n", __FILE__, __FUNCTION__, __LINE__);					free(pVideo);					break;				}				memcpy(frame.frame_data, pVideo->frame_body, pVideo->frame_head.len);				if(qh_stream_sendFrameToPool(&frame) != 0)				{					//printf("%s --> %s --> L%d : qh_stream_sendFrameToPool failed \n", __FILE__, __FUNCTION__, __LINE__);				}				free(frame.frame_data);				free(pVideo);				break;			}			case STREAM_C_MSG_TYPE:			{//����ظ���Ϣ				net_msg_t* net_msg = (net_msg_t*)(p_data+sizeof(frame_head_t));				printf("%s --> %s --> L%d : recv response:%#x \n", __FILE__, __FUNCTION__, __LINE__, net_msg->msg_head.msg_type);				switch(net_msg->msg_head.msg_type)				{					case MSG_REQUEST_VIDEO:					{						//g_map_msg[net_msg->msg_head.msg_type] = (char*)(p_data+sizeof(frame_head_t));						pthread_mutex_lock(&mtx_opreview);						pthread_cond_signal(&cond_opreview);						pthread_mutex_unlock(&mtx_opreview);						break;					}					case MSG_CLOSE_VIDEO:					{						//g_map_msg[net_msg->msg_head.msg_type] = (char*)(p_data+sizeof(frame_head_t));						pthread_mutex_lock(&mtx_spreview);						pthread_cond_signal(&cond_spreview);						pthread_mutex_unlock(&mtx_spreview);						break;					}					case MSG_GET_PARAM:					{					     printf("MSG_GET_PARAM \n");						char* p_buf = (char*)malloc(p_head->frame_size);						memcpy(p_buf, p_data+sizeof(frame_head_t), p_head->frame_size);						g_map_msg[net_msg->msg_head.msg_type] = p_buf;						pthread_mutex_lock(&mtx_gparam);						pthread_cond_signal(&cond_gparam);						pthread_mutex_unlock(&mtx_gparam);						break;					}					case MSG_SET_PARAM:					{					    printf("MSG_SET_PARAM \n");						char* p_buf = (char*)malloc(p_head->frame_size);						memcpy(p_buf, p_data+sizeof(frame_head_t), p_head->frame_size);						g_map_msg[net_msg->msg_head.msg_type] = p_buf;						pthread_mutex_lock(&mtx_sparam);						pthread_cond_signal(&cond_sparam);						pthread_mutex_unlock(&mtx_sparam);						printf("MSG_SET_PARAM 1111\n");						break;					}					case MSG_GET_VERSION_INFO:					{					    printf("MSG_GET_VERSION_INFO \n");						char* p_buf = (char*)malloc(p_head->frame_size);						memcpy(p_buf, p_data+sizeof(frame_head_t), p_head->frame_size);						g_map_msg[net_msg->msg_head.msg_type] = p_buf;						pthread_mutex_lock(&mtx_version);						pthread_cond_signal(&cond_version);						pthread_mutex_unlock(&mtx_version);						break;					}					case MSG_UPDATE_USER:					{						printf("MSG_UPDATE_USER \n");						char* p_buf = (char*)malloc(p_head->frame_size);						memcpy(p_buf, p_data+sizeof(frame_head_t), p_head->frame_size);						g_map_msg[net_msg->msg_head.msg_type] = p_buf;						pthread_mutex_lock(&mtx_update);						pthread_cond_signal(&cond_update);						pthread_mutex_unlock(&mtx_update);					}					default:					{					    printf("default \n");					}						break;				}				break;			}			case STREAM_C_ALARM_TYPE:			{//����Ǳ�������ʹ��net_msg��ʽ����ֱ����int				int* d = (int*)(p_data+sizeof(frame_head_t));				int alarm = *d;				//printf("-----------------alarm : %d-----------------\n", alarm);				if(alarm & 2)				{					if(cover_state == 0)					{						//printf("-----------------cover alarm open-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 1, 1, NULL, 0);						}						cover_state = 1;					}				}				else				{					if(cover_state == 1)					{						//printf("-----------------cover alarm close-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 1, 0, NULL, 0);						}						cover_state = 0;					}				}				if(alarm & 4)				{					if(enter_state == 0)					{						//printf("-----------------enter alarm open-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 2, 1, NULL, 0);						}						enter_state = 1;					}				}				else				{					if(enter_state == 1)					{						//printf("-----------------enter alarm close-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 2, 0, NULL, 0);						}						enter_state = 0;					}				}				if(alarm & 8)				{					if(pass_state == 0)					{						//printf("-----------------pass alarm close-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 3, 1, NULL, 0);						}						pass_state = 1;					}				}				else				{					if(pass_state == 1)					{						//printf("-----------------pass alarm close-----------------\n");						if(g_cb_alarm)						{							g_cb_alarm(1, 3, 0, NULL, 0);						}						pass_state = 0;					}				}				break;			}			default:				break;		}		int nSize = p_head->frame_size + sizeof(frame_head_t);		p_data += nSize;		len -= nSize;	}	return NULL;}int read_frame(void){	struct v4l2_buffer buf;	CLEAR(buf);	int counts =0;	buf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;	buf.memory=V4L2_MEMORY_MMAP;	pthread_mutex_lock(&mtx_ctrl);	int rets=ioctl(gfd,VIDIOC_DQBUF,&buf);	pthread_mutex_unlock(&mtx_ctrl);	if(rets < 0)	{		printf("%s --> %s --> L%d : ioctl VIDIOC_DQBUF failed error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));		return -1;	}	assert(buf.index < n_buffers);	ProcessImageData(buffers[buf.index].start,buf.bytesused);	pthread_mutex_lock(&mtx_ctrl);	rets = ioctl(gfd,VIDIOC_QBUF,&buf);	pthread_mutex_unlock(&mtx_ctrl);	if(rets < 0)	{		printf("%s --> %s --> L%d : ioctl VIDIOC_QBUF failed error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno) );		return -1;	}	return 1;}void* threadpro(void* param){	pthread_detach(pthread_self());	while(run)	{		if(gfd == -1)		{			usleep(100*1000);			continue;		}		int r;		int ret = -1;		fd_set fds;		FD_ZERO(&fds);		FD_SET(gfd, &fds);		struct timeval tv;		tv.tv_sec = 0;		tv.tv_usec = 10;	    r = select(gfd + 1, &fds, NULL, NULL, &tv);		if (-1 == r)		{			printf("%s --> %s --> L%d : select error[%d:%s] \n", __FILE__, __FUNCTION__, __LINE__, errno, strerror(errno));			CloseDevide();		}		else if(0 < r)		{			ret = read_frame();			if(ret == -1)			{				CloseDevide();			}		}		else		{			pthread_mutex_lock(&mtx_send);			int size = g_list_send.size();			if(size == 0)			{				pthread_mutex_unlock(&mtx_send);				continue;			}			send_msg_t* p_send = g_list_send.front();			g_list_send.pop_front();			pthread_mutex_unlock(&mtx_send);			ret = SendData(p_send->msg_type , p_send->sub_type, p_send->p_buffer, p_send->size);			if(ret != 0)			{			//	printf("%s --> %s --> L%d : SendData %#x:%#x failed \n", __FILE__, __FUNCTION__, __LINE__, p_send->msg_type , p_send->sub_type);				CloseDevide();			}			if(p_send->p_buffer)			{				free(p_send->p_buffer);			}			free(p_send);		}		if(gfd == -1 && OfflineCallback != NULL)		{			OfflineCallback(1);		}	}	printf("close threadpro\n");	CloseDevide();	return NULL;}static int qh_open_video0(){	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->p_buffer = malloc(sizeof(msg_preview_t));	if(p_send->p_buffer == NULL)	{		free(p_send);		return -1;	}	memset(p_send->p_buffer, 0, sizeof(msg_preview_t));	msg_preview_t* p = (msg_preview_t*)p_send->p_buffer;	p->stream = 0;	p_send->size = sizeof(msg_preview_t);	p_send->msg_type = MSG_REQUEST_VIDEO;	p_send->sub_type = 0;	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_opreview);	int result = pthread_cond_timedwait(&cond_opreview, &mtx_opreview, &timeout );	pthread_mutex_unlock(&mtx_opreview);	if(result != 0)	{		printf("%s --> %s --> L%d : SendData MSG_REQUEST_VIDEO failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	return 0;}static int qh_open_video1(){	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->p_buffer = malloc(sizeof(msg_preview_t));	if(p_send->p_buffer == NULL)	{		free(p_send);		return -1;	}	msg_preview_t preview;	memset(&preview,0,sizeof(preview));	preview.stream = 1;	memcpy(p_send->p_buffer, &preview, sizeof(msg_preview_t));	p_send->size = sizeof(msg_preview_t);	p_send->msg_type = MSG_REQUEST_VIDEO;	p_send->sub_type = 0;	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_opreview);	int result = pthread_cond_timedwait(&cond_opreview, &mtx_opreview, &timeout );	pthread_mutex_unlock(&mtx_opreview);	if(result != 0)	{		printf("%s --> %s --> L%d : SendData MSG_REQUEST_VIDEO failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	return 0;}void* online_thread(void* p){	pthread_detach(pthread_self());	while(run)	{		if(gfd < 0)		{			main_flag = 0;			sub_flag = 0;			reconnect++;			//printf("%s --> %s --> L%d : open '%s' %d times \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME, reconnect);			int fd = OpenUvcCamera();			if(fd < 0)			{				usleep(3*1000*1000);				continue;			}			gfd = fd;			reconnect = 0;			usleep(100*1000);			printf("%s --> %s --> L%d : open '%s' success \n", __FILE__, __FUNCTION__, __LINE__, DEVICE_NAME);		}		else		{			if(main_flag == 0)			{				int r = qh_open_video0();				if(r == 0)				{					main_flag = 1;					printf("%s --> %s --> L%d : open main stream success \n", __FILE__, __FUNCTION__, __LINE__);				}			}			usleep(1000*1000);			if(sub_flag == 0)			{				int r = qh_open_video1();				if(r == 0)				{					sub_flag = 1;					printf("%s --> %s --> L%d : open sub stream success \n", __FILE__, __FUNCTION__, __LINE__);				}			}			usleep(1000*1000);		}	}	return NULL;}int qh_cam_open(offline_callback callback){	if(run == 1)	{		return 0;	}	//��ʼ������	stream_param_t stream_param;	stream_param.ch_num = 2;	stream_param.stream_ch_attr[0].data_space     = 5*1024*1024;	stream_param.stream_ch_attr[0].index_num      = (5*1024*1024)/1024;	stream_param.stream_ch_attr[0].max_frame_size = 800*1024;	stream_param.stream_ch_attr[1].data_space     = 3*1024*1024;	stream_param.stream_ch_attr[1].index_num      = (3*1024*1024)/1024;	stream_param.stream_ch_attr[1].max_frame_size = 500*1024;	OfflineCallback = callback;	if(qh_stream_init_avstream(&stream_param) != 0)	{		printf("%s --> %s --> L%d : qh_stream_init_avstream failed \n", __FILE__, __FUNCTION__, __LINE__);	    return -1;	}	run = 1;	pthread_t id;	int ret = pthread_create(&id,NULL,threadpro,NULL);	if(ret != 0)	{		printf("%s --> %s --> L%d : create threadpro failed \n", __FILE__, __FUNCTION__, __LINE__);		run = 0;		qh_stream_destroy_avstream();		return -1;	}	pthread_t id2;	ret = pthread_create(&id2,NULL,online_thread,NULL);	if(ret != 0)	{		printf("%s --> %s --> L%d : create online_thread failed \n", __FILE__, __FUNCTION__, __LINE__);		run = 0;		qh_stream_destroy_avstream();		return -1;	}	pthread_t id_server;	ret = pthread_create(&id_server, NULL, server_work_thread, NULL);	if(ret != 0)	{		printf("%s --> %s --> L%d : create server_work_thread failed \n", __FILE__, __FUNCTION__, __LINE__);		run = 0;		qh_stream_destroy_avstream();		return -1;	}	return 0;}void qh_cam_close(){	run = 0;	qh_stream_destroy_avstream();}int qh_cam_status(){	return (gfd >= 0);}void set_alarm_callback(alarm_callback callback){	g_cb_alarm = callback;}int qh_cam_set_alarm(int alarm_type, alarm_param_t alarm_data){	if(gfd < 0)		return -1;	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	switch(alarm_type)	{		case 1://遮挡		{			xarina_ta_arlam_t param = {0};			param.enable = alarm_data.enable;			if(alarm_data.enable)			{				param.time_schedule_week.enable_flag = 1;				for(int i = 0; i < 7; i++)				{					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_hour = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_minute = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_second = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_hour = 23;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_minute = 59;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_second = 59;				}			}			p_send->p_buffer = malloc(sizeof(xarina_ta_arlam_t));			if(p_send->p_buffer == NULL)			{				printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);				free(p_send);				return -1;			}			memcpy(p_send->p_buffer, &param, sizeof(xarina_ta_arlam_t));			p_send->size = sizeof(xarina_ta_arlam_t);			p_send->msg_type = MSG_SET_PARAM;			p_send->sub_type = PARAM_VIDEO_COVER;			pthread_mutex_lock(&mtx_send);			g_list_send.push_back(p_send);			pthread_mutex_unlock(&mtx_send);			break;		}		case 2://入侵		{			xarina_vmf_info_t param = {0};			param.enable = alarm_data.enable;			printf("alarm_data.enable = %d",alarm_data.enable);			if(alarm_data.enable)			{				param.event = 0;				param.pointnum = 4;				param.movingDirection = 0;				param.sensitive_level = 5;				param.vmf_rect.locate_point[0].x = alarm_data.left_up.x;				param.vmf_rect.locate_point[0].y = alarm_data.left_up.y;				param.vmf_rect.locate_point[1].x = alarm_data.right_up.x;				param.vmf_rect.locate_point[1].y = alarm_data.right_up.y;				param.vmf_rect.locate_point[2].x = alarm_data.right_down.x;				param.vmf_rect.locate_point[2].y = alarm_data.right_down.y;				param.vmf_rect.locate_point[3].x = alarm_data.left_down.x;				param.vmf_rect.locate_point[3].y = alarm_data.left_down.y;				param.time_schedule_week.enable_flag = 1;				for(int i = 0; i < 7; i++)				{					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_hour = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_minute = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_second = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_hour = 23;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_minute = 59;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_second = 59;				}			}			p_send->p_buffer = malloc(sizeof(xarina_vmf_info_t));			if(p_send->p_buffer == NULL)			{				printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);				free(p_send);				return -1;			}			memcpy(p_send->p_buffer, &param, sizeof(xarina_vmf_info_t));			p_send->size = sizeof(xarina_vmf_info_t);			p_send->msg_type = MSG_SET_PARAM;			p_send->sub_type = PARAM_VIDEO_ENTER;			pthread_mutex_lock(&mtx_send);			g_list_send.push_back(p_send);			pthread_mutex_unlock(&mtx_send);			break;		}		case 3://越界		{			xarina_vmf_info_t param = {0};			param.enable = alarm_data.enable;			if(alarm_data.enable)			{				param.event = 1;				param.pointnum = 2;				param.movingDirection = alarm_data.drt;				param.sensitive_level = 5;				param.vmf_rect.locate_point[0].x = alarm_data.left_up.x;				param.vmf_rect.locate_point[0].y = alarm_data.left_up.y;				param.vmf_rect.locate_point[1].x = alarm_data.right_up.x;				param.vmf_rect.locate_point[1].y = alarm_data.right_up.y;				param.time_schedule_week.enable_flag = 1;				for(int i = 0; i < 7; i++)				{					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_hour = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_minute = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].start_second = 0;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_hour = 23;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_minute = 59;					param.time_schedule_week.time_schedule_day[i].time_seg[0].end_second = 59;				}			}			p_send->p_buffer = malloc(sizeof(xarina_vmf_info_t));			if(p_send->p_buffer == NULL)			{				free(p_send);				printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);				return -1;			}			memcpy(p_send->p_buffer, &param, sizeof(xarina_vmf_info_t));			p_send->size = sizeof(xarina_vmf_info_t);			p_send->msg_type = MSG_SET_PARAM;			p_send->sub_type = PARAM_VIDEO_PASS;			pthread_mutex_lock(&mtx_send);			g_list_send.push_back(p_send);			pthread_mutex_unlock(&mtx_send);			break;		}		default:		{			free(p_send);			return -1;		}	}	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_sparam);	int result = pthread_cond_timedwait(&cond_sparam, &mtx_sparam, &timeout );	pthread_mutex_unlock(&mtx_sparam);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);		//free(p_send);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_SET_PARAM);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_GET_PARAM) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)	{		printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);		free(net_msg);		return -1;	}	free(net_msg);	return 0;}int qh_cam_get_alram(int alarm_type, alarm_param_t* p_data){	if(p_data == NULL)		return -1;	if(gfd < 0)		return -1;	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		printf("%s --> %s --> L%d : qh_cam_get_alram failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->size = 0;	p_send->msg_type = MSG_GET_PARAM;	switch(alarm_type)	{		case 1://�ڵ�		{			p_send->sub_type = PARAM_VIDEO_COVER;			break;		}		case 2://����		{			p_send->sub_type = PARAM_VIDEO_ENTER;			break;		}		case 3://Խ��		{			p_send->sub_type = PARAM_VIDEO_PASS;			break;		}		default:		{			printf("%s --> %s --> L%d : qh_cam_get_alram failed \n", __FILE__, __FUNCTION__, __LINE__);			free(p_send);			return -1;		}	}	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_gparam);	int result = pthread_cond_timedwait(&cond_gparam, &mtx_gparam, &timeout );	pthread_mutex_unlock(&mtx_gparam);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_get_alram failed \n", __FILE__, __FUNCTION__, __LINE__);		//free(p_send);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_GET_PARAM);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_GET_PARAM) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.msg_subtype == PARAM_VIDEO_COVER)	{		xarina_ta_arlam_t* p_param = (xarina_ta_arlam_t*)(net_msg->msg_data);		memset(p_data, 0, sizeof(alarm_param_t));		p_data->enable = p_param->enable;		free(net_msg);	}	else if(net_msg->msg_head.msg_subtype == PARAM_VIDEO_ENTER)	{		xarina_vmf_info_t* p_param = (xarina_vmf_info_t*)(net_msg->msg_data);		memset(p_data, 0, sizeof(alarm_param_t));		p_data->enable = p_param->enable;		p_data->left_up.x = p_param->vmf_rect.locate_point[0].x;		p_data->left_up.y = p_param->vmf_rect.locate_point[0].y;		p_data->right_up.x = p_param->vmf_rect.locate_point[1].x;		p_data->right_up.y = p_param->vmf_rect.locate_point[1].y;		p_data->right_down.x = p_param->vmf_rect.locate_point[2].x;		p_data->right_down.y = p_param->vmf_rect.locate_point[2].y;		p_data->left_down.x = p_param->vmf_rect.locate_point[3].x;		p_data->left_down.y = p_param->vmf_rect.locate_point[3].y;		p_data->drt = 0;		free(net_msg);	}	else if(net_msg->msg_head.msg_subtype == PARAM_VIDEO_PASS)	{		xarina_vmf_info_t* p_param = (xarina_vmf_info_t*)(net_msg->msg_data);		memset(p_data, 0, sizeof(alarm_param_t));		p_data->enable = p_param->enable;		p_data->left_up.x = p_param->vmf_rect.locate_point[0].x;		p_data->left_up.y = p_param->vmf_rect.locate_point[0].y;		p_data->right_up.x = p_param->vmf_rect.locate_point[1].x;		p_data->right_up.y = p_param->vmf_rect.locate_point[1].y;		p_data->drt = p_param->movingDirection;		free(net_msg);	}	return 0;}int qh_cam_set_localtime(time_t utcSec, int zone, int dstTm){	if(gfd < 0)		return -1;	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		//printf("%s --> %s --> L%d : malloc failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->p_buffer = malloc(sizeof(localTime_config_t));	if(p_send->p_buffer == NULL)	{		//printf("%s --> %s --> L%d : malloc failed \n", __FILE__, __FUNCTION__, __LINE__);		free(p_send);		return -1;	}	memset(p_send->p_buffer, 0, sizeof(localTime_config_t));	localTime_config_t localtime = {0};	localtime.utcSec = utcSec;	localtime.zone = zone;	localtime.dstTm = dstTm;	memcpy(p_send->p_buffer, &localtime, sizeof(localTime_config_t));	p_send->size = sizeof(localTime_config_t);	p_send->msg_type = MSG_SET_PARAM;	p_send->sub_type = PARAM_LOCALTIME;	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_sparam);	int result = pthread_cond_timedwait(&cond_sparam, &mtx_sparam, &timeout );	pthread_mutex_unlock(&mtx_sparam);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_set_alarm failed \n", __FILE__, __FUNCTION__, __LINE__);		//free(p_send);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_SET_PARAM);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_GET_PARAM) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)	{		printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);		free(net_msg);		return -1;	}	free(net_msg);	return 0;}int qh_cam_get_localtime(localTime_config_t* p_localtime){	if(gfd < 0)		return -1;	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		printf("%s --> %s --> L%d : qh_cam_get_alram failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->size = 0;	p_send->msg_type = MSG_GET_PARAM;	p_send->sub_type = PARAM_LOCALTIME;	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//�ȴ�ظ�	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_gparam);	int result = pthread_cond_timedwait(&cond_gparam, &mtx_gparam, &timeout );	pthread_mutex_unlock(&mtx_gparam);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_gettime can not recv rsp \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_GET_PARAM);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_GET_PARAM) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)	{		printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);		free(net_msg);		return -1;	}	memcpy(p_localtime, net_msg->msg_data, sizeof(localTime_config_t));	free(net_msg);	return 0;}int qh_cam_get_version(version_info_t* p_version_out){	if(gfd < 0)		return -1;	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		printf("%s --> %s --> L%d : malloc failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->size = 0;	p_send->msg_type = MSG_GET_VERSION_INFO;	p_send->sub_type = 0;	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	//等待回复	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+1;	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_version);	int result = pthread_cond_timedwait(&cond_version, &mtx_version, &timeout );	pthread_mutex_unlock(&mtx_version);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_gettime can not recv rsp \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_GET_VERSION_INFO);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_GET_VERSION_INFO) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)	{		printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);		free(net_msg);		return -1;	}	memcpy(p_version_out, net_msg->msg_data, sizeof(version_info_t));	free(net_msg);	return 0;}int qh_cam_set_update(long size, char *buf, upgrade_callback callback){	if(gfd < 0)	{		return -1;	}	printf("%s --> %s --> L%d : size is %ld, buf is %p \n", __FILE__, __FUNCTION__, __LINE__, size, buf);	send_msg_t* p_send = (send_msg_t*)malloc(sizeof(send_msg_t));	if(p_send == NULL)	{		printf("%s --> %s --> L%d : malloc failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	memset(p_send, 0, sizeof(send_msg_t));	p_send->p_buffer = (char *)malloc(BUF_SIZE);	if(p_send->p_buffer == NULL)	{		printf("%s --> %s --> L%d : malloc failed \n", __FILE__, __FUNCTION__, __LINE__);		free(p_send);		return -1;	}	UpgradeCallback = callback;	p_send->msg_type = MSG_UPDATE_USER;	p_send->sub_type = 0;	// 拷贝数据	memcpy(p_send->p_buffer, buf, size);	p_send->size =(int)size;	printf("[%s-%d]:%dB--%dB\n", __func__, __LINE__, p_send->size, size);	pthread_mutex_lock(&mtx_send);	g_list_send.push_back(p_send);	pthread_mutex_unlock(&mtx_send);	/*	int i = 0;	for(i = 0; i < 120; i++)	{//每30S判断一次是否断线		struct timeval now;		gettimeofday(&now, NULL);		struct timespec timeout;		timeout.tv_sec=now.tv_sec+30; // 30s		timeout.tv_nsec=now.tv_usec*1000;		pthread_mutex_lock(&mtx_update);		int result = pthread_cond_timedwait(&cond_update, &mtx_update, &timeout );		pthread_mutex_unlock(&mtx_update);		if(result == 0)		{			std::map<int, char*>::iterator it = g_map_msg.find(MSG_UPDATE_USER);			if(it == g_map_msg.end())			{				printf("%s --> %s --> L%d : g_map_msg.find(MSG_UPDATE_USER) failed \n", __FILE__, __FUNCTION__, __LINE__);				return -1;			}			net_msg_t* net_msg = (net_msg_t*)(it->second);			g_map_msg.erase(it);			if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)			{				printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);				free(net_msg);				return -1;			}			free(net_msg);			return 0;		}		else		{			if(gfd < 0)			{				printf("%s --> %s --> L%d : idarling disconnect \n", __FILE__, __FUNCTION__, __LINE__);				return -1;			}		}	}	return -1;	*/	struct timeval now;	gettimeofday(&now, NULL);	struct timespec timeout;	timeout.tv_sec=now.tv_sec+3600; // 1 hour	timeout.tv_nsec=now.tv_usec*1000;	pthread_mutex_lock(&mtx_update);	int result = pthread_cond_timedwait(&cond_update, &mtx_update, &timeout );	pthread_mutex_unlock(&mtx_update);	if(result != 0)	{		printf("%s --> %s --> L%d : qh_cam_set_update failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	std::map<int, char*>::iterator it = g_map_msg.find(MSG_UPDATE_USER);	if(it == g_map_msg.end())	{		printf("%s --> %s --> L%d : g_map_msg.find(MSG_UPDATE_USER) failed \n", __FILE__, __FUNCTION__, __LINE__);		return -1;	}	net_msg_t* net_msg = (net_msg_t*)(it->second);	g_map_msg.erase(it);	if(net_msg->msg_head.ack_flag != ACK_SUCCESSFUL)	{		printf("%s --> %s --> L%d : ack_flag != ACK_SUCCESSFUL \n", __FILE__, __FUNCTION__, __LINE__);		free(net_msg);		return -1;	}	free(net_msg);	return 0;}